Контейнерные компоненты (container components) в Redux - это специальные компоненты React, которые связывают компоненты вашего приложения с хранилищем Redux. Они обеспечивают связь между состоянием в хранилище и свойствами компонента, а также предоставляют доступ к действиям для обновления состояния.

Контейнерные компоненты выполняют следующие задачи:

1. Подписка на состояние: Контейнерные компоненты подписываются на изменения состояния в хранилище Redux с помощью функции `connect` из пакета `react-redux`. Это позволяет компоненту получать актуальные данные из хранилища при их изменении.

2. Передача данных компонентам: Контейнерные компоненты выбирают необходимые данные из состояния хранилища и передают их в качестве свойств (props) обычным компонентам, которые затем используют эти данные для отображения или выполнения логики.

3. Отправка действий в хранилище: Контейнерные компоненты предоставляют обработчики событий или методы, которые отправляют действия (actions) в хранилище Redux с помощью функции `dispatch`. Это позволяет обновлять состояние приложения и вызывать соответствующие изменения.

Пример контейнерной компоненты с использованием функции `connect`:

```javascript
import { connect } from 'react-redux';
import { incrementCounter } from '../actions';
import MyComponent from './MyComponent';

const mapStateToProps = (state) => {
  return {
    counter: state.counter
  };
};

const mapDispatchToProps = (dispatch) => {
  return {
    incrementCounter: () => dispatch(incrementCounter())
  };
};

const MyComponentContainer = connect(mapStateToProps, mapDispatchToProps)(MyComponent);

export default MyComponentContainer;
```

В этом примере `MyComponentContainer` - это контейнерная компонента, которая использует функцию `connect` для связи с хранилищем Redux. Функция `mapStateToProps` отображает состояние из хранилища на свойства компонента, а `mapDispatchToProps` отображает действия на свойства компонента. Затем контейнерная компонента экспортируется для использования в приложении.

Контейнерные компоненты позволяют разделить логику управления состоянием от компонентов, отвечающих за отображение и взаимодействие с пользователем. Они обеспечивают более чистую архитектуру приложения и упрощают тестирование, масштабирование и поддержку кода.
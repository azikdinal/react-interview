В React для изменения состояния компонента используется метод `setState()`. Метод `setState()` позволяет обновлять состояние компонента, что ведет к перерисовке компонента и обновлению его отображения.

В классовых компонентах метод `setState()` вызывается непосредственно на экземпляре компонента и принимает в качестве аргумента объект с обновленными значениями состояния или функцию, возвращающую такой объект. Вот пример использования `setState()` в классовом компоненте:

```jsx
import React, { Component } from 'react';

class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.handleClick()}>Increment</button>
      </div>
    );
  }
}
```

В этом примере, при нажатии кнопки "Increment", вызывается метод `handleClick()`, который вызывает `setState()` для обновления значения свойства `count`. В `setState()` передается объект с обновленным значением `count`, и React автоматически обновляет компонент и его отображение.

В функциональных компонентах с использованием хука `useState()` для изменения состояния используется функция, возвращаемая хуком. Эта функция принимает новое значение состояния или функцию, которая обновляет состояние на основе предыдущего значения. Вот пример использования `useState()` для изменения состояния в функциональном компоненте:

```jsx
import React, { useState } from 'react';

const MyComponent = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
};
```

В этом примере, при нажатии кнопки "Increment", вызывается функция `handleClick`, которая использует `setCount` для обновления значения состояния `count`. Затем React обновляет компонент и его отображение.

Важно отметить, что метод `setState()` и функция, возвращаемая `useState()`, асинхронны, поэтому при обновлении состояния следует учитывать возможность асинхронного поведения. Если новое состояние зависит от предыдущего состояния, лучше использовать функцию, передаваемую в `setState()` или `setCount()`, чтобы гарантировать правильное обновление состояния.